<script src="../lib/fx.js"></script>

## L.flatten

<script>
	log([...[1, 2], 3, 4, ...[5, 6], ...[7, 8, 9]]);	

	const isIterable = a => a && a[Symbol.iterator];

	L.flatten = function* (iter) {
		for (const a of iter) {
			if (isIterable(a)) for (const b of a) yield b
			else yield a;
		}
	};

	var it = L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]);
	log(it.next());
	log(it.next());
	log(it.next());
	log(it.next());
	log(take(6, L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]])));

	//log(it.next());
	//log(it.next());
	//log(it.next());
	//log(it.next());
	const flatten = pipe(L.flatten, takeAll);
	log(take(6, L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]])));
	
	console.clear();
</script>

## yield *

<script>
	L.flatten = function* (iter) {
		for (const a of iter) {
			if (isIterable(a)) for (const b of a) yield b
			else yield a;
		}
	};
</script>

`yield *`을 활용하면 위 코드를 아래와 같이 변경할 수 있습니다. `yield *iterable`은 `for (const val of iterable) yield val`과 같습니다.

<script>
	L.flatten = function* (iter) {
		for (const a of iter) {
			if (isIterable(a)) yield* a;
			else yield a;
		}
	};
</script>

## L.deepFlat

만일 깊은 Iterable을 모두 펼치고 싶다면 아래와 같이 `L.deepFlat`을 구현하여 사용할 수 있습니다. `L.deepFlat`은 갚은 Iterable을 펼쳐줍니다.

<script>
	L.deepFlat = function* f(iter) {
		for (const a of iter) {
			if (isIterable(a)) yield* f(a);
			else yield a;
		}
	};
	log([...L.deepFlat([1, [2, [3, 4], [[5]]]])]);
	// [1, 2, 3, 4, 5];
</script>

## L.flatMap

<script>
	//log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a));
	//log([[1, 2], [3, 4], [5, 6, 7]].flatMap(a => a.map(a => a * a)));
	//log(flatten([[1, 2], [3, 4], [5, 6, 7]].map(a => a.map(a => a * a))));
	//log(flatten([[1, 2], [3, 4], [5, 6, 7]].map(a => a.map(a => a * a))));

	L.flatMap = curry(pipe(L.map, L.flatten));
	const flatMap = curry(pipe(L.map, flatten));

	var it = L.flatMap(map(a => a * a), [[1, 2], [3, 4], [5, 6, 7]]);
</script>


















